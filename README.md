# ðŸš€ Framework

_A minimal yet powerful web framework with builtin support for ssr html pages and SPA microfrontend splits_

**Features**:

- Simple routing & templating (HTML/Go templates)
- Automatic microfrontend support for multiple SPAs
- 1 Go dependency: esbuild
  - Use anything esbuild supports, like TypeScript, JavaScript, JSX, TSX, and CSS
- NO NodeJS process required - no Webpack, Babel, Vite, Rollup, etc.
- Clean `/templates` + `/frontend` folder structure
- Autoreload when in development mode
- Optional Accompanying JavaScript library for frontend development
  - Server Sent Events handler, Router, state management, and elements
  -

---

## ðŸš¦ Quickstart

### 1. Project Structure

```shell
your-project/
â”œâ”€â”€ templates/          # HTML templates & components
â”‚   â”œâ”€â”€ base.html       # Required: Base layout
â”‚   â”œâ”€â”€ entry.html      # Required: html snippet with js and css imports - autogenerated by esbuild on changes
â”‚   â”œâ”€â”€ index.html      # Required: Default html page
â”‚   â”œâ”€â”€ other.html      # "/other" route auto-registered
â”‚   â””â”€â”€ app.subroute.html # "/app/" subroute auto-registered for the app - an easy way to add a new SPA
â”œâ”€â”€ static # bundled js files place here, you can .gitignore this
â”œâ”€â”€ frontend/
â”‚   â””â”€â”€  src/
â”‚      â””â”€â”€ index.ts        # Your frontend entrypoint, customize and codesplit as needed
â””â”€â”€ main.go             # Your server
```

2. Get started with all the defaults:

```go
package main

import (
	"net/http"

	"github.com/bencbradshaw/framework"
)

func main() {
	http.ListenAndServe(":2025", framework.Run(nil))
}
```

3. Override the defaults:

```go
package main

import (
	"net/http"
	"os"

	"github.com/bencbradshaw/framework"

	"github.com/evanw/esbuild/pkg/api"
)

func main() {
	mux := framework.Run(framework.InitParams{
		IsDevMode: false,
		AutoRegisterTemplateRoutes: false,
		EsbuildOpts: api.BuildOptions{
			EntryPoints: []string{"./app/src/my-app.tsx"},
		},
	})
	// add your own routes, the same as you would with the default mux
	mux.Handle("/api/hello-world", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Write([]byte("Hello, World!"))
	}))
	http.ListenAndServe(":2025", mux)
}
```

### ðŸš§ In Progress Features

- **Support for Multiple Base Templates**

  - Allow customization of JavaScript or CSS for different templates.
  - Your home page and about page might need different CSS or JS loaded.

- **Image Hosting**

  - Provide built-in support for serving and managing images.
  - This will be simply a folder served with static files

- **Authentication Guard**

  - Offer a middleware mechanism to enable developers to implement custom authentication logic for route handlers.
  - Rather than providing an authentication system, this will allow developers to use their own authentication systems that can tie into the framework.

- **Customizable Templates Directory**

  - Ensure the `/templates` directory path can be configured as needed.

- **Template Naming Conventions**

To ensure clarity, maintainability, and proper functioning of the routing and rendering system, this framework relies on specific naming conventions for files within the `/templates` directory.

### Core Templates (Required)

These files are essential for the framework's operation:

*   **`base.html`**:
    *   **Purpose**: This is the main layout or master template. It defines the overall HTML structure (e.g., `<html>`, `<head>`, `<body>`) and usually includes common elements like headers, footers, and navigation. It should also define a `{{define "content"}}...{{end}}` block where page-specific content will be injected.
    *   **Requirement**: Mandatory. The rendering system always uses this as the foundation for any page.

*   **`entry.html`**:
    *   **Purpose**: This template is responsible for including JavaScript and CSS assets.
    *   **Content**: Contains `<script>` and `<link rel="stylesheet">` tags. It is typically auto-generated by the `esbuild` process during development and builds, ensuring that the correct, bundled assets are referenced.
    *   **Requirement**: Mandatory. It's always loaded to ensure necessary styles and scripts are available.

*   **`index.html`**:
    *   **Purpose**: Serves as the default page for the root route (`/`).
    *   **Content**: Contains the specific HTML content for your site's homepage. This content fills the `content` block in `base.html`.
    *   **Requirement**: Mandatory for displaying a default landing page.

### Page Templates

For standard, individual pages of your website:

*   **Naming Pattern**: `[name].html` (e.g., `about.html`, `profile.html`, `contact-us.html`)
*   **Routing**: The framework automatically registers a route based on the filename. For example, `about.html` will be accessible at `/about`, and `contact-us.html` at `/contact-us`.
*   **Purpose**: These templates provide the specific content for individual pages, typically by defining the `content` block that `base.html` will render.
*   **Location**: Place these files directly in the `/templates` directory.

### Sub-route Templates (for SPAs or Sections)

For Single Page Applications (SPAs) or distinct, self-contained sections of your website:

*   **Naming Pattern**: `[name].subroute.html` (e.g., `app.subroute.html`, `dashboard.subroute.html`)
*   **Routing**: Creates a base route for the section. For example, `app.subroute.html` serves as the entry point for everything under the `/app/` path. Further client-side routing within the SPA would then take over.
*   **Purpose**: Designed as the HTML entry point for an SPA or a significant, encapsulated part of your application. This template provides the initial shell into which the JavaScript application loads.
*   **Location**: Place these files directly in the `/templates` directory.

Understanding and adhering to these conventions will ensure your templates are correctly discovered and rendered by the framework.

### Future Considerations

*   **Validation & Guidance**: In future versions, the framework could introduce build-time or startup checks to validate these naming conventions. This could involve warning about missing required templates (like `base.html` or `index.html`) or providing more specific error messages if conventions are not followed, helping developers adhere to the structure more easily.
